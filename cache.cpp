#include "cache.h"
#include <iostream>

#define DEBUG_CACHE 1
using namespace std;

cache::cache(unsigned int csize, unsigned int ways, unsigned int bsize, int htime, int mtime, int trantime, int bwidth){
    cache_size = csize;
    assoc = ways;
    block_size = bsize;
    table_size = (cache_size/block_size)/assoc;
    
    block_offset = log2(block_size);
    index_offset = log2(table_size);

    hit_time = htime;
    miss_time = mtime;
    transfer_time = trantime;
    bus_width = bwidth;

    table = new set[table_size];
    //Initialize all sets
    for (unsigned int i = 0; i < table_size; i++){
	table[i].assoc = assoc;
	table[i].blocks = new block[assoc];

	//Initialize LRU
	table[i].LRU = new LRU_stack(assoc);

	//I believe this is unneccessary. It can be added back in if it becomes necessary
	/*for (int j = 0; j < assoc; j++){
	  table[i].blocks[j].block_size = block_size;
	  }*/
    }
}

unsigned int cache::log2(unsigned int x){
    unsigned int log2x = 0;
    unsigned int comp = 0x01;
    while((x & comp) == 0){
	comp = comp << 1;
	log2x++;
    }
    return log2x;
}
bool cache::read(unsigned long long int address, unsigned int bytesize){
    bool hit = false; // Record a hit or miss
    // Going to adjust the tag by shifting out low order bits by
    // block_offset and index_offset.
    unsigned long long int tag = address >> block_offset;
    tag = tag >> index_offset;

#if DEBUG_CACHE == 1
    cout << "Address: 0x" << hex << address;
    cout << "Block offset: " << dec << block_offset;
    cout << " Resulting tag: 0x" << hex << tag << endl;
#endif
    //We need to check for mis-aligned references and odd bytesizes
    // I'm thinking we do (address%4 + bytesize)/4 to see how many 
    // references we need to make. This will work for all cases where
    // the sum is >= 4. If less than 4, the result will be 0. What
    // we must do then, is max(1, (address%4 + bytesize)/4) to see
    // the number of references generated by the request.
    int num_requests = max((unsigned long long int) 1, (address%4 + bytesize)/4);

    //Increment counter for requests
    requests += num_requests;

#if DEBUG_CACHE == 1
    cout << "Address%4 = " << address%4;
    cout << " Bytesize = " << bytesize << endl;
    cout << "Number of requests = " << num_requests << endl;
#endif
    //Must perform the read for each of the bytes of the mis-aligned
    //request. This is the ((address + 4*i)>> block_offset)...
    //[index_offset-1:0]; i = 0..num_requests - 1

    unsigned int eff_index; // effective index used for the request

    // We want the mask to be all 1's for the index
    unsigned long long int mask;
    mask = (unsigned long long int) table_size - 1;

    for (int i = 0; i < num_requests; i++){
	// (Address + 4*i)
	eff_index = (address + ((unsigned long long int)i<<2));
	// (address + 4*i) >> block_offset
	eff_index = address >> block_offset;
	// Get the index
	eff_index = (unsigned int)(tag & mask);

	/*The hard part: Checking if the read was successful
	  Step 1: For each block in the table[eff_index]:
	    Check if block is valid
	      IF YES: Check if block's tag matches
	        IF YES: Mark a hit, update LRU, increment time by hit_time, BREAK out of for loop
	  Step 2: Check if hit was recorded
	    IF YES: CONTINUE through for loop
	    IF NO: Record a miss, increment kickout,  get block index to replace from LRU, ???possibly increment transfer???
	      Check if table[eff_index].blocks[LRU_index] is dirty
	      IF YES: need to write to next level, increment dirty kickouts, read from next level, increment timers accordingly
	      IF NO: Need to read from next level, dont need to write, increment timers accordingly
	   
	 */
    }
    
    return true;
}
void cache::printInfo(){
    cout << "Cache Size: " << cache_size << endl;
    cout << "Block Size: " << block_size << " Associativity: " << assoc << endl;
    cout << "Table Size: " << table_size << endl;
    cout << "Timing== " ;
    cout << "Hit: " << hit_time << "   Miss: " << miss_time << endl;
    cout << "Transfer Time: " << transfer_time << "   Bus Width: " << bus_width << endl;
}


void cache::printCounts(){
    cout << "Hit count," << hit_count << endl;
    cout << "Miss count," << miss_count << endl;
    cout << "Requests," << requests << endl;
    cout << "Kickouts," << kickouts << endl;
    cout << "Dirty kickouts," << dirty_kickouts << endl;
    cout << "Transfers," << transfers << endl;
    cout << "Flush Kickouts" << flush_kickouts << endl;
}
