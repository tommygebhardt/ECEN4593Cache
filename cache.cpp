#include "cache.h"
#include <iostream>

#define DEBUG_CACHE 1
using namespace std;

cache::cache(unsigned int csize, unsigned int ways, unsigned int bsize, int htime, int mtime, int trantime, int bwidth){
    cache_size = csize;
    assoc = ways;
    block_size = bsize;
    table_size = (cache_size/block_size)/assoc;
    
    block_offset = log2(block_size);
    index_offset = log2(table_size);

    hit_time = htime;
    miss_time = mtime;
    transfer_time = trantime;
    bus_width = bwidth;

    table = new set[table_size];
    //Initialize all sets
    for (unsigned int i = 0; i < table_size; i++){
	table[i].assoc = assoc;
	table[i].blocks = new block[assoc];

	//Initialize LRU
	table[i].LRU = new LRU_stack(assoc);

	//I believe this is unneccessary. It can be added back in if it becomes necessary
	/*for (int j = 0; j < assoc; j++){
	  table[i].blocks[j].block_size = block_size;
	  }*/
    }
}

unsigned int cache::log2(unsigned int x){
    unsigned int log2x = 0;
    unsigned int comp = 0x01;
    while((x & comp) == 0){
	comp = comp << 1;
	log2x++;
    }
    return log2x;
}
bool cache::read(unsigned long long int address, unsigned int bytesize){
    
    // Going to adjust the tag by shifting out low order bits by
    // block_offset and index_offset. block_offset first because
    // we don't care about they byte within the block
    unsigned long long int tag = address >> block_offset;
#if DEBUG_CACHE == 1
    cout << "Address: 0x" << hex << address;
    cout << " Bytesize: " << dec << bytesize << endl;
    cout << "Block offset: " << dec << block_offset;
    cout << " Resulting tag: 0x" << hex << tag << endl;
#endif
    // We want the mask to be all 1's for the index
    unsigned long long int mask;
    mask = (unsigned long long int) table_size - 1;
    // Get the index
    unsigned int index = (unsigned int)(tag & mask);
    // find the tag
    tag = tag >> index_offset;
#if DEBUG_CACHE == 1
    cout << "Table size: " << dec << table_size;
    cout << " Resulting mask: 0x" << hex << mask << endl;
    cout << "Index = 0x" << hex << index;
    cout << " New Tag = 0x" << hex << tag << endl;
#endif
    //We need to check for mis-aligned references and odd bytesizes
    // I'm thinking we do (address%4 + bytesize)/4 to see how many 
    // references we need to make. This will work for all cases where
    // the sum is >= 4. If less than 4, the result will be 0. What
    // we must do then, is max(1, (address%4 + bytesize)/4) to see
    // the number of references generated by the request.
    int num_requests = max((unsigned long long int) 1, (address%4 + bytesize)/4);
    requests += num_requests;
#if DEBUG_CACHE == 1
    cout << "Address%4 = " << address%4;
    cout << " Bytesize = " << bytesize << endl;
    cout << "Number of requests = " << num_requests << endl;
#endif
    //Must perform the read for each of the bytes of the mis-aligned
    //request. This is the (address >> block_offset)[index_offset-1:0]
    // + i; i = 0..num_requests - 1
    for (int i = 0; i < num_requests; i++){
    }
    
    return true;
}
void cache::printInfo(){
    cout << "Cache Size: " << cache_size << endl;
    cout << "Block Size: " << block_size << " Associativity: " << assoc << endl;
    cout << "Table Size: " << table_size << endl;
    cout << "Timing== " ;
    cout << "Hit: " << hit_time << "   Miss: " << miss_time << endl;
    cout << "Transfer Time: " << transfer_time << "   Bus Width: " << bus_width << endl;
}


void cache::printCounts(){
    cout << "Hit count," << hit_count << endl;
    cout << "Miss count," << miss_count << endl;
    cout << "Requests," << requests << endl;
    cout << "Kickouts," << kickouts << endl;
    cout << "Dirty kickouts," << dirty_kickouts << endl;
    cout << "Transfers," << transfers << endl;
    cout << "Flush Kickouts" << flush_kickouts << endl;
}
